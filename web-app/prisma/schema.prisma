// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String    @id @default(uuid())
  name             String
  email            String
  emailVerified    Boolean
  image            String?
  createdAt        DateTime
  updatedAt        DateTime
  twoFactorEnabled Boolean?
  role             String?
  banned           Boolean?
  banReason        String?
  banExpires       DateTime?

  sessions    Session[]
  accounts    Account[]
  members     Member[]
  invitations Invitation[]
  twofactors  TwoFactor[]
  passkeys    Passkey[]

  userAgentRating    UserAgentRating[]
  agentLists         AgentList[]
  creditTransactions CreditTransaction[]

  jobs Job[]

  @@unique([email])
  @@map("user")
}

model Session {
  id                   String   @id
  expiresAt            DateTime
  token                String
  createdAt            DateTime
  updatedAt            DateTime
  ipAddress            String?
  userAgent            String?
  userId               String
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  activeOrganizationId String?
  impersonatedBy       String?

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Organization {
  id          String       @id
  name        String
  slug        String?
  logo        String?
  createdAt   DateTime
  metadata    String?
  members     Member[]
  invitations Invitation[]

  @@unique([slug])
  @@map("organization")
}

model Member {
  id             String       @id
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           String
  teamId         String?
  createdAt      DateTime

  @@map("member")
}

model Invitation {
  id             String       @id
  organizationId String
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  email          String
  role           String?
  teamId         String?
  status         String
  expiresAt      DateTime
  inviterId      String
  user           User         @relation(fields: [inviterId], references: [id], onDelete: Cascade)

  @@map("invitation")
}

model TwoFactor {
  id          String @id
  secret      String
  backupCodes String
  userId      String
  user        User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("twoFactor")
}

model Passkey {
  id           String    @id
  name         String?
  publicKey    String
  userId       String
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  credentialID String
  counter      Int
  deviceType   String
  backedUp     Boolean
  transports   String?
  createdAt    DateTime?

  @@map("passkey")
}

model RateLimit {
  id          String  @id
  key         String?
  count       Int?
  lastRequest BigInt?

  @@map("rateLimit")
}

model UnitValue {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  unit      String
  amount    BigInt

  agentFixedPricing   AgentFixedPricing? @relation(fields: [agentFixedPricingId], references: [id])
  agentFixedPricingId String?
  paymentRequestId    String?
  purchaseRequestId   String?
}

model AgentPricing {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  pricingType         PricingType
  fixedPricing        AgentFixedPricing? @relation(fields: [agentFixedPricingId], references: [id])
  agentFixedPricingId String?            @unique
  agent               Agent?
}

enum PricingType {
  Fixed
}

model AgentFixedPricing {
  id           String        @id @default(cuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  agentPricing AgentPricing?
  amounts      UnitValue[]
}

model ExampleOutput {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String
  mimeType  String
  url       String

  agent           Agent?  @relation("ExampleOutputAgent", fields: [agentId], references: [id])
  agentId         String?
  agentOverride   Agent?  @relation("ExampleOutputAgentOverride", fields: [agentIdOverride], references: [id])
  agentIdOverride String?
}

model UserAgentRating {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  stars       Int
  title       String?
  description String?
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  agentId     String
  agent       Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
}

model AgentRating {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  totalStars   BigInt
  totalRatings BigInt
  agent        Agent?
}

model Agent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  blockchainIdentifier String @unique

  rating   AgentRating @relation(fields: [ratingId], references: [id])
  ratingId String      @unique

  name         String
  overrideName String?

  description         String?
  overrideDescription String?

  apiBaseUrl         String
  overrideApiBaseUrl String?

  capabilityName         String
  overrideCapabilityName String?

  capabilityVersion         String
  overrideCapabilityVersion String?

  authorName         String
  overrideAuthorName String?

  authorContactEmail         String?
  overrideAuthorContactEmail String?

  authorContactOther         String?
  overrideAuthorContactOther String?

  authorOrganization         String?
  overrideAuthorOrganization String?

  legalPrivacyPolicy         String?
  overrideLegalPrivacyPolicy String?

  legalTerms         String?
  overrideLegalTerms String?

  legalOther         String?
  overrideLegalOther String?

  lastUptimeCheck  DateTime
  uptimeCount      Int
  uptimeCheckCount Int

  image         String
  overrideImage String?

  metadataVersion Int @default(1)

  pricing   AgentPricing @relation(fields: [pricingId], references: [id])
  pricingId String       @unique

  status AgentStatus @default(ONLINE)

  showOnFrontPage Boolean
  ranking         BigInt

  exampleOutput         ExampleOutput[] @relation("ExampleOutputAgent")
  overrideExampleOutput ExampleOutput[] @relation("ExampleOutputAgentOverride")

  userAgentRating UserAgentRating[]
  agentLists      AgentList[]
  jobs            Job[]

  tags         Tag[] @relation("AgentTag")
  overrideTags Tag[] @relation("AgentTagOverride")
}

model Lock {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  key       String    @unique
  isLocked  Boolean
  lockedAt  DateTime?
  lockedBy  String?
}

model Tag {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String   @unique

  agents         Agent[] @relation("AgentTag")
  agentsOverride Agent[] @relation("AgentTagOverride")
}

enum AgentStatus {
  ONLINE
  OFFLINE
  DEREGISTERED
  INVALID
}

model AgentList {
  id     String        @id @default(cuid())
  user   User          @relation(fields: [userId], references: [id])
  userId String
  type   AgentListType
  agents Agent[]
}

enum AgentListType {
  FAVORITE
}

model CreditTransaction {
  id            String                @id @default(cuid())
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  amount        BigInt //positive is always a credit topup and negative is always a credit spend
  includedFee   BigInt
  note          String?
  noteKey       String?
  errorNote     String?
  errorNoteKey  String?
  type          CreditTransactionType
  userId        String
  user          User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  fiatPayment   FiatPayment?          @relation(fields: [fiatPaymentId], references: [id])
  fiatPaymentId String?               @unique

  status      CreditTransactionStatus @default(PENDING)
  job         Job?                    @relation("JobCost")
  refundedJob Job?                    @relation("JobRefund")
}

enum CreditTransactionStatus {
  PENDING
  SUCCEEDED
  FAILED
}

enum CreditTransactionType {
  TOP_UP
  REFERRAL
  SPEND
  REFUND
  MANUAL
}

model FiatPayment {
  id                String             @id @default(cuid())
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  amount            BigInt // Amount in cents/smallest currency unit
  currency          String // e.g., "usd"
  status            FiatPaymentStatus
  servicePaymentId  String             @unique // Stripe's payment_intent ID
  serviceCustomerId String? // Stripe's customer ID
  metadata          Json? // Additional payment metadata
  creditTransaction CreditTransaction?
  service           FiatPaymentService @default(STRIPE)
}

enum FiatPaymentService {
  STRIPE
}

enum FiatPaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
  CANCELLED
}

model Job {
  id                        String             @id @default(cuid())
  createdAt                 DateTime           @default(now())
  updatedAt                 DateTime           @updatedAt
  agentJobId                String
  paymentId                 String
  agentId                   String
  agent                     Agent              @relation(fields: [agentId], references: [id])
  userId                    String
  user                      User               @relation(fields: [userId], references: [id])
  status                    JobStatus
  input                     String
  output                    String?
  startedAt                 DateTime           @default(now())
  finishedAt                DateTime?
  cost                      CreditTransaction  @relation("JobCost", fields: [creditTransactionId], references: [id])
  refundCreditTransaction   CreditTransaction? @relation("JobRefund", fields: [refundCreditTransactionId], references: [id])
  refundCreditTransactionId String?            @unique
  creditTransactionId       String             @unique
  errorNote                 String?
  errorNoteKey              String?

  blockchainIdentifier      String    @unique
  submitResultTime          DateTime?
  unlockTime                DateTime?
  externalDisputeUnlockTime DateTime?
  sellerVkey                String?
  identifierFromPurchaser   String?
}

enum JobStatus {
  PAYMENT_PENDING
  PAYMENT_FAILED
  PROCESSING
  COMPLETED
  FAILED
  REFUND_REQUESTED
  DISPUTED
  REFUNDED
  REFUND_FAILED
}

model CreditCost {
  id                String   @id @default(cuid())
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  unit              String   @unique
  creditCostPerUnit BigInt
}
