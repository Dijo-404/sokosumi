// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(uuid())
  name          String
  email         String
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  sessions      Session[]
  accounts      Account[]

  userAgentRatings   UserAgentRating[]
  agentLists         AgentList[]
  creditTransactions CreditTransaction[]
  fiatTransactions   FiatTransaction[]
  jobs               Job[]

  stripeCustomerId String?

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model RateLimit {
  id          String  @id
  key         String?
  count       Int?
  lastRequest BigInt?

  @@map("rateLimit")
}

model UnitValue {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  unit      String
  amount    BigInt

  agentFixedPricing   AgentFixedPricing? @relation(fields: [agentFixedPricingId], references: [id])
  agentFixedPricingId String?
  paymentRequestId    String?
  purchaseRequestId   String?
}

model AgentPricing {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  pricingType         PricingType
  fixedPricing        AgentFixedPricing? @relation(fields: [agentFixedPricingId], references: [id])
  agentFixedPricingId String?            @unique
  agent               Agent?
}

enum PricingType {
  FIXED
}

model AgentFixedPricing {
  id           String        @id @default(cuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  agentPricing AgentPricing?
  amounts      UnitValue[]
}

model ExampleOutput {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String
  mimeType  String
  url       String

  agent           Agent?  @relation("ExampleOutputAgent", fields: [agentId], references: [id])
  agentId         String?
  agentOverride   Agent?  @relation("ExampleOutputAgentOverride", fields: [agentIdOverride], references: [id])
  agentIdOverride String?
}

model UserAgentRating {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  stars       Int
  title       String?
  description String?
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  agentId     String
  agent       Agent    @relation(fields: [agentId], references: [id], onDelete: Cascade)
}

model AgentRating {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  totalStars   BigInt
  totalRatings BigInt
  agent        Agent?
}

model Agent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  blockchainIdentifier String @unique

  rating   AgentRating @relation(fields: [ratingId], references: [id])
  ratingId String      @unique

  name         String
  overrideName String?

  description         String?
  overrideDescription String?

  apiBaseUrl         String
  overrideApiBaseUrl String?

  capabilityName         String
  overrideCapabilityName String?

  capabilityVersion         String
  overrideCapabilityVersion String?

  authorName         String
  overrideAuthorName String?

  authorContactEmail         String?
  overrideAuthorContactEmail String?

  authorContactOther         String?
  overrideAuthorContactOther String?

  authorOrganization         String?
  overrideAuthorOrganization String?

  legalPrivacyPolicy         String?
  overrideLegalPrivacyPolicy String?

  legalTerms         String?
  overrideLegalTerms String?

  legalOther         String?
  overrideLegalOther String?

  lastUptimeCheck  DateTime
  uptimeCount      Int
  uptimeCheckCount Int

  image         String
  overrideImage String?

  metadataVersion Int @default(1)

  pricing   AgentPricing @relation(fields: [pricingId], references: [id])
  pricingId String       @unique

  status AgentStatus @default(ONLINE)

  isShown Boolean

  exampleOutput         ExampleOutput[] @relation("ExampleOutputAgent")
  overrideExampleOutput ExampleOutput[] @relation("ExampleOutputAgentOverride")

  userAgentRating UserAgentRating[]
  agentLists      AgentList[]
  jobs            Job[]

  tags         Tag[] @relation("AgentTag")
  overrideTags Tag[] @relation("AgentTagOverride")
}

model Lock {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  key       String    @unique
  isLocked  Boolean
  lockedAt  DateTime?
  lockedBy  String?
}

model Tag {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String   @unique

  agents         Agent[] @relation("AgentTag")
  agentsOverride Agent[] @relation("AgentTagOverride")
}

enum AgentStatus {
  ONLINE
  OFFLINE
  DEREGISTERED
  INVALID
}

model AgentList {
  id     String        @id @default(cuid())
  user   User          @relation(fields: [userId], references: [id])
  userId String
  type   AgentListType
  agents Agent[]
}

enum AgentListType {
  FAVORITE
}

model CreditTransaction {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  amount      BigInt //positive is always a credit topup and negative is always a credit spend; 1_000_000_000_000 = 1 credit (10^12) with NEXT_PUBLIC_CREDITS_BASE = 12
  includedFee BigInt @default(0)

  note         String?
  noteKey      String?
  errorNote    String?
  errorNoteKey String?

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  fiatTransaction   FiatTransaction?
  fiatTransactionId String?          @unique

  job         Job? @relation("CreditTransactionJob")
  refundedJob Job? @relation("RefundedCreditTransactionJob")
}

model FiatTransaction {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  amount           BigInt // Base Unit: 100 = 1 USD, 10000 = 100 USD if currency is USD
  currency         String
  centsPerAmount   BigInt
  servicePaymentId String?               @unique
  service          FiatService           @default(STRIPE)
  status           FiatTransactionStatus @default(PENDING)

  userId String
  user   User   @relation(fields: [userId], references: [id])

  creditTransaction   CreditTransaction? @relation(fields: [creditTransactionId], references: [id])
  creditTransactionId String?            @unique
}

enum FiatTransactionStatus {
  PENDING
  SUCCEEDED
  FAILED
}

enum FiatService {
  STRIPE
}

model Job {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id])

  agentId String
  agent   Agent  @relation(fields: [agentId], references: [id])

  agentJobId String
  paymentId  String
  status     JobStatus
  input      String
  output     String?
  startedAt  DateTime  @default(now())
  finishedAt DateTime?

  errorType String?

  errorNote    String?
  errorNoteKey String?

  blockchainIdentifier      String    @unique
  submitResultTime          DateTime?
  unlockTime                DateTime?
  externalDisputeUnlockTime DateTime?
  sellerVkey                String?
  identifierFromPurchaser   String?

  creditTransaction           CreditTransaction  @relation("CreditTransactionJob", fields: [creditTransactionId], references: [id])
  creditTransactionId         String             @unique
  refundedCreditTransaction   CreditTransaction? @relation("RefundedCreditTransactionJob", fields: [refundedCreditTransactionId], references: [id])
  refundedCreditTransactionId String?            @unique
}

enum JobStatus {
  AGENT_CONNECTION_FAILED
  PAYMENT_NODE_CONNECTION_FAILED

  PAYMENT_PENDING
  PAYMENT_FAILED

  INPUT_REQUIRED

  PROCESSING
  COMPLETED
  FAILED

  DISPUTE_REQUESTED
  DISPUTE_RESOLVED

  REFUND_REQUESTED
  REFUND_RESOLVED

  UNKNOWN
}

model CreditCost {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  unit         String   @unique
  centsPerUnit BigInt
}
